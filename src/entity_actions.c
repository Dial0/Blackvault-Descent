
typedef enum {
	ACT_MOVE,
	ACT_MELEE_ATK,
	ACT_RANGED_ATK
}ActionType;

typedef struct {
	ActionType type;
	union {
		struct { Vector2 direction; float speed; } move;
		struct { int weapon_id; float power; } melee;
		struct { int weapon_id; float power; } ranged;
	};
} EntityAction;

// ?? Handler function prototype ?????????????????????????????????????????

typedef void (*EntityActionHandler)(const EntityAction* cmd);

// ?? Individual handlers ????????????????????????????????????????????????

static void actionMove(const EntityAction* cmd) {
	//printf("Moving: %.1f, %.1f @ speed %.1f\n",
	//	cmd->move.direction.x,
	//	cmd->move.direction.y,
	//	cmd->move.speed);
}

static void actionMelee(const EntityAction* cmd) {
	//printf("Shooting weapon %d with power %.1f\n",
	//	cmd->melee.weapon_id,
	//	cmd->melee.power);
}

static void actionRanged(const EntityAction* cmd) {
	//printf("Shooting weapon %d with power %.1f\n",
	//	cmd->melee.weapon_id,
	//	cmd->melee.power);
}

// ?? Dispatch table ?????????????????????????????????????????????????????

static const EntityActionHandler handlers[] = {
	[ACT_MOVE] = actionMove,
	[ACT_MELEE_ATK] = actionMelee,
	[ACT_RANGED_ATK] = actionRanged
};

// ?? Dispatcher ?????????????????????????????????????????????????????????

void processEntityAction(const EntityAction* action) {
	if (action->type >= sizeof(handlers) / sizeof(handlers[0]) || !handlers[action->type]) {
		//fprintf(stderr, "Unknown or unimplemented command: %d\n", action->type);
		return;
	}

	handlers[action->type](action);
}

// ?? Usage example ??????????????????????????????????????????????????????

int ActionExample(void) {
	EntityAction commands[] = {
		{.type = ACT_MOVE,  .move = { {1.0f, -2.0f}, 5.5f } },
		{.type = ACT_MELEE_ATK, .melee = { 1, 100.0f } },
		{.type = ACT_RANGED_ATK,  .ranged = { 1, 100.0f } }
	};

	for (int i = 0; i < sizeof(commands) / sizeof(commands[0]); i++) {
		//printf("Processing command %zu: ", i);
		processEntityAction(&commands[i]);
	}

	return 0;
}